"""
Marantz has an RS232 interface to control the receiver.

Not all receivers have all functions.
Functions can be found on in the xls file within this repository
"""

import codecs
import socket
from time import sleep
from marantz_receiver.marantz_commands import CMDS
import serial  # pylint: disable=import-error
import threading
import telnetlib
import logging
import time

DEFAULT_TIMEOUT = 0.5
DEFAULT_WRITE_TIMEOUT = 0.5

_LOGGER = logging.getLogger(__name__)

class MarantzReceiver(object):
    """Marantz receiver."""

    def __init__(self, serial_port, timeout=DEFAULT_TIMEOUT,
                 write_timeout=DEFAULT_WRITE_TIMEOUT):
        """Create RS232 connection."""
        self.ser = serial.Serial(serial_port, baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=timeout,
                                 write_timeout=write_timeout)
        self.lock = threading.Lock()

    def exec_command(self, domain, function, operator, value=None):
        """
        Write a command to the receiver and read the value it returns.
        The receiver will always return a value, also when setting a value.
        """
        raw_command = CMDS[domain][function]['cmd']
        if operator in CMDS[domain][function]['supported_operators']:
            if value is None:
                raise ValueError('No value provided')
            else:
                cmd = ''.join([raw_command, operator, str(value)])

        else:
            raise ValueError('Invalid operator provided %s' % operator)
        with self.lock:
            if not self.ser.is_open:
                self.ser.open()

            self.ser.reset_input_buffer()
            self.ser.reset_output_buffer()
    
            # Marantz uses the prefix @ and the suffix \r, so add those to the above cmd.
            final_command = ''.join(['@', cmd, '\r']).encode('utf-8')
            _LOGGER.debug ('Send Command %s',final_command)
    
            self.ser.write(final_command)
    
            msg = self.ser.read_until(bytes('\r'.encode()))

        _LOGGER.debug ('Response msg %s', msg.decode())

        split_string = msg.decode().strip().split(':')

        _LOGGER.debug("Decoded split string %s", split_string)
        _LOGGER.debug ("Original command: %s", raw_command)
        # Check return value contains the same command value as requested. Sometimes the marantz gets out of sync. Ignore if this is the case
        if split_string[0] != ('@' + raw_command):
            _LOGGER.debug ("Send & Response command values dont match %s != %s - Ignoring returned value", split_string[0], '@' + raw_command )
            return None
        else:
             return split_string[1]
             # b'AMT:0\r will return 0

    def main_mute(self, operator, value=None):
        """Execute Main.Mute."""
        return self.exec_command('main', 'mute', operator, value)

    def main_power(self, operator, value=None):
        """Execute Main.Power."""
        return self.exec_command('main', 'power', operator, value)

    def main_volume(self, operator, value=None):
        """
        Execute Main.Volume.
        Returns int
        """
        vol_result = self.exec_command('main', 'volume', operator, value)
        if vol_result != None:
            return int(vol_result)

    def main_source(self, operator, value=None):
        """Execute Main.Source."""
        result = self.exec_command('main', 'source', operator, value)
        """
        The receiver often returns the source value twice. If so take the
        second value as the source, otherwise return original
        """
        if result != None and len(result) == 2:
            _LOGGER.debug("Source Result: %s", result[1])
            return result[1]
        else:
            return result

    def main_sound_mode(self, operator, value=None):
        """Execute Main.SoundMode."""
        result_sound_mode = self.exec_command('main', 'sound_mode', operator, value)

        if result_sound_mode != None :
            return result_sound_mode

    def main_autostatus (self, operator, value=None):
        """
        Execute autostatus.
        Not currently used but will allow two-way communications in future

        Returns int
        """
        return int(self.exec_command('main', 'autostatus', operator, value))